#1. Generate the means of the x and y coordinates for each group using the kmeans function with a large number of iterations.
#2. Use the means generated by kmeans as the center points for each group.
#3. Generate the points for each group using the rnorm function with the means generated by kmeans as the center points.
#This modification uses the kmeans function with a large number of iterations to generate the means of the x and y coordinates for each group. 
#This way, it is less likely that the clusters will overlap or be too close to one another.

generate_clusters <-
  function(num_groups = NULL,
           group_sizes = NULL,
           group_names = NULL,
           spread = 0.5,
           shape = "random") {
    if (is.null(num_groups)) {
      num_groups <- length(unique(group_names))
    }
    if (is.null(group_sizes)) {
      group_sizes <- rep(10, num_groups)
    }
    if (is.null(group_names)) {
      group_names <- paste0("Group ", 1:num_groups)
    }
    
    # Generate the means of the x and y coordinates for each group.
    #kmeans needs a large number of data points to generate the means.
    data <-
      data.frame(x = rnorm(num_groups * 10, 0, 1),
                 y = rnorm(num_groups * 10, 0, 1))
    # nstart: algorithm will be run with 100 different centroid seeds.
    kmeans_result <-
      kmeans(data, num_groups, nstart = 100, iter.max = 1000)
    # center points of each cluster.
    means_x <- kmeans_result$centers[, 1]
    means_y <- kmeans_result$centers[, 2]
    
    xy_coords <- data.frame(x = numeric(0), y = numeric(0))
    
    for (i in 1:num_groups) {
      if (shape == "square") {
        xy_coords_temp <-
          data.frame(
            x = runif(group_sizes[i], means_x[i] - spread, means_x[i] + spread),
            y = runif(group_sizes[i], means_y[i] -
                        spread, means_y[i] + spread)
          )
      } else if (shape == "round") {
        #generate a random radius and angle for each point.
        r <- runif(group_sizes[i], 0, spread)
        theta <- runif(group_sizes[i], 0, 2 * pi)
        #convert them to Cartesian coordinates.
        xy_coords_temp <- data.frame(x = means_x[i] + r * cos(theta),
                                     y = means_y[i] + r * sin(theta))
      } else {
        xy_coords_temp <-
          data.frame(
            x = rnorm(group_sizes[i], means_x[i], spread),
            y = rnorm(group_sizes[i], means_y[i], spread)
          )
      }
      xy_coords_temp$group <- group_names[i]
      xy_coords <- rbind(xy_coords, xy_coords_temp)
    }
    return(split(xy_coords, xy_coords$group))
  }
      


# clusters <-
#   generate_clusters(num_groups = 10,
#                     group_sizes = rep(100, 10),
#                     spread = 0.3,
#                     shape = "round")
# 
# clusters
# clusters_data <- bind_rows(clusters)
# ggplot(clusters_data, aes(x, y, color = as.factor(group))) + 
#   geom_point()+
#   theme(legend.position = "none")


